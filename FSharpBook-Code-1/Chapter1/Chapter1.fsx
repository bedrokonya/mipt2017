// =============================================================
// Дмитрий Сошников: Функциональное программирования на языке F#
//                               http://www.soshnikov.com/fsharp
// -------------------------------------------------------------
// Глава 1: Основы функционального программирования
// =============================================================

// Для выполнения примеров в Visual Studio надо открыть внизу окно F# Interactive
// View -> Other Windows -> F# Interactive
// Далее выделяется фрагмент текста и нажимаете Alt-Enter - он выполняется
// в окне F# Interactive
// ;; означает конец фрагмента текста, который обрабатывается интерпретатором за один раз

// Вычисление дескриминанта
let D = 2.0*2.0-4.0*(-3.0) in (-2.0+sqrt(D)) / 2.0 ;;

// решение простейшего квадратного уравнения
let a = 1.0 in
 let b = 2.0 in
  let c = -3.0 in
   let D = b*b-4.*a*c in
    (-b+sqrt(D)) / (2.*a) ;;

// Решим квадратное уравнение - вернём пару решений
let a = 1.0 in
 let b = 2.0 in
  let c = -3.0 in
   let D = b*b-4.*a*c in
    ((-b+sqrt(D))/(2.*a),(-b-sqrt(D))/(2.*a)) ;;

// Можно вернуть не пару решений, а список из двух решений
// Это удобно делать, когда количество возвращаемых значений может меняться
let a = 1.0 in
 let b = 2.0 in
  let c = -3.0 in
   let D = b*b-4.*a*c in
    [(-b+sqrt(D))/(2.*a);(-b-sqrt(D))/(2.*a)];;

// Определим функцию для решения квадратного уравнения и применим её к конкретным данным
let solve (a,b,c) =
   let D = b*b-4.*a*c in
    ((-b+sqrt(D))/(2.*a),(-b-sqrt(D))/(2.*a))
 in solve (1.0,2.0,-3.0);;

// Более привычный синтаксис - сначала описание функции, потом её применение к аргументам
let solve (a,b,c) =
   let D = b*b-4.*a*c
   ((-b+sqrt(D))/(2.*a),(-b-sqrt(D))/(2.*a));
solve (1.0,2.0,-3.0);;

// Описать функцию можно и так - с помощью ключевого слова fun
// fun создаёт функциональную константу, с ней можно потом делать что угодно
let solve = fun (a,b,c) ->
   let D = b*b-4.*a*c
   ((-b+sqrt(D))/(2.*a),(-b-sqrt(D))/(2.*a));
solve (1.0,2.0,-3.0);;

// Каррирование - описание функций с несколькими аргументами как функций высшего порядка
let plus (x,y) = x+y // некаррированная функция сложения. аргумент - пара чисел
let cplus x y = x+y  // каррированная функция сложения.
let cplus = fun x -> (fun y -> x+y) // другой способ описания каррированной функции, который помогает понять, что происходит

let incr = cplus 1 // каррированную функцию можно частично применить к меньшему числу аргументов и получить в рез-тате функцию 

(+) 1 2;; // стандартный оператор + тоже описан в каррированной форме
let incr = (+)1;;

// Решение квадратного уравнения в "правильном" (каррированном) виде
let solve a b c =
   let D = b*b-4.*a*c
   ((-b+sqrt(D))/(2.*a),(-b-sqrt(D))/(2.*a));;
solve 1.0 2.0 -3.0;;

// Частичное применение позволяет описать функцию решения линейных уравнений.
// Жаль, она бесполезна из-за деления на 0
let solve_lin = solve 0.0;;

// Функция решения квадратных уравнений, учитывающая отсутствие корней
// Возвращает опициональный тип
let solve a b c =
   let D = b*b-4.*a*c
   if D<0. then None
   else Some(((-b+sqrt(D))/(2.*a),(-b-sqrt(D))/(2.*a)));;

let res = solve 1.0 2.0 -3.0 in
 if res = None 
   then "Нет решений"
   else 
    Option.get(res).ToString();;

// Для самого общего результата решения квадратного уравнения опишем специальный тип
type SolveResult =
   None
 | Linear of float
 | Quadratic of float*float;;

let solve a b c =
   let D = b*b-4.*a*c
   if a=0. then
     if b=0. then None
     else Linear(-c/b)
   else
     if D<0. then None
     else Quadratic(((-b+sqrt(D))/(2.*a),(-b-sqrt(D))/(2.*a)));;

// Используем сопоставление с образцом (match) для работы со значениями типа SolveResult
let res = solve 1.0 2.0 3.0 
match res with
  None -> printf "Нет решений"
| Linear(x) -> printf "Линейное уравнение, корень: %f" x
| Quadratic(x1,x2) -> printf "Квадратное уравнение, корни: %f %f" x1 x2
;;

let res = solve 1.0 2.0 3.0 
match res with
  None -> printf "Нет решений"
| Linear(x) -> printf "Линейное уравнение, корень: %f" x
| Quadratic(x1,x2) when x1=x2 -> printf "Квадратное уравнение, один корень: %f" x1
| Quadratic(x1,x2) -> printf "Квадратное уравнение, два корня: %f %f" x1 x2
;;

// Функция преобразования результата в текст
let text_res x = match x with
  None -> "Нет решений"
| Linear(x) -> "Линейное уравнение, корень: "+x.ToString()
| Quadratic(x1,x2) when x1=x2 -> "Квадратное уравнение, один корень: "+x1.ToString()
| Quadratic(x1,x2) -> "Квадратное уравнение, два корня:"+x1.ToString()+x2.ToString()
;;

// Функция может быть описана с помощью ключевого слова function
// Это аналог fun, но допускает только один аргумент и сопоставление с образцом
let text_res = function
  None -> "Нет решений"
| Linear(x) -> "Линейное уравнение, корень: "+x.ToString()
| Quadratic(x1,x2) when x1=x2 -> "Квадратное уравнение, один корень: "+x1.ToString()
| Quadratic(x1,x2) -> "Квадратное уравнение, два корня:"+x1.ToString()+x2.ToString()
;;

text_res(solve 1.0 2.0 3.0);;

// Организация цикла в функциональном подходе
let rec for_loop f A B =
  if A>=B then f A
  else 
    f A
    for_loop f (A+1) B;;

for_loop (fun x -> printf "%d " x) 1 10;;

// В F# также присутствуют встроенные конструкции цикла со счетчиком
for x=1 to 10 do printf "%d " x;;
for x in 1..10 do printf "%d " x;;

// Более сложный пример: функция n-кратного вычисления f(f(...f(f(x))...)
let rec rpt n f x =
    if n=0 then x
    else f (rpt (n-1) f x);;

// Другой способ описания с помощью оператора композиции >>
let rec rpt n f =
    if n=0 then fun x->x
    else f >> (rpt (n-1) f);;

// Вот как могут быть описаны операторы композиции и последовательного применения (pipeline)
let (>>) f g x = f(g x);;
let (|>) x f = f x

// Примеры использования операторов pipeline
solve 1.0 2.0 3.0 |> text_res |> System.Console.Write;;
System.Console.Write(text_res(solve 1.0 2.0 3.0))
printfn "%s" <| (text_res <| (solve 1.0 2.0 3.0))
