// =============================================================
// Дмитрий Сошников: Функциональное программирования на языке F#
//                               http://www.soshnikov.com/fsharp
// -------------------------------------------------------------
// Глава 3: Приёмы функционального программирования - генераторы
// =============================================================


// Пример: счётчик, выдающий очередное значение при каждом обращении

// Ячейка, необходимая для хранения mutable-значения
// Имя, захватываемое в замыкание, не может быть mutable само по себе
type cell = { mutable content : int };;
    
let new_counter n =
  let x = { content = n } in // захватываем ячейку с начальным значением счётчика в замыкание
  fun () ->                  // возвращаем функцию, которая изменяет счётчик и возвращает очередное значение
    (x.content <- x.content+1; x.content);;
    
// Аналогичный счётчик с использованием встроенного в F# механизма ссылок ref

let new_counter n =
  let x = ref n in
  fun () ->
    (x := !x+1; !x);;

// Функция для создания произвольного генератора
// init - начальное значение
// fgen - функция, применяемая к начальному значению для получения следующего    
let new_generator fgen init =
  let x = ref init in
  fun () ->
    (x:=fgen !x; !x);;

// Простой счетчик с использованием конструктора генераторов
let new_counter n = new_generator (fun x-> x+1) n;;

// Генератор пар чисел Фибоначчи
let fibgen = new_generator (fun (u,v) -> (u+v,u)) (1,1);;
  
// Функция отображения над генераторами
// Возвращает функцию, которая при каждом обращении обращается 
// к исходному генератору, и возвращает преобразованное значение
let map f gen =
  fun () -> f (gen());;

let fib = map (fun (u,v) -> u) fibgen;;

// Попробуем определить функцию фильтрации генератора
let rec repeat cond gen =
  let x = gen() in
  if cond x then x
  else repeat cond gen;;
  
let filter cond gen =
  fun () -> repeat cond gen;;

// Берём первые n значений и преобразуем их в список
let rec take n gen =
   if n=0 then []
   else gen()::take (n-1) gen;;

take 10 fib;;
take 10 (filter (fun x -> x%3=0) fib);;
