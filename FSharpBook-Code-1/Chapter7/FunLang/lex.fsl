//--------------------------------------------------------------
// Part I. Supporting F# definitions. Everything between braces
// is F# code added to the generated file.

{
module Lex
open System
open Pars
open Microsoft.FSharp.Text.Lexing

// Fslex generated parsers follow the same pattern as OCamllex 
// and Mossmllex generated parsers, and do not update line number 
// information automatically, partly because the knowledge of when 
// a newline has occured is best placed in the lexer rules. 
// Thus the following boiler-plate code is very useful:

let record_newline (lexbuf : LexBuffer<_>) = lexbuf.EndPos <- lexbuf.EndPos.NextLine

}

//--------------------------------------------------------------
// Part II. Define some regular expressions
//
// These are some regular expression definitions

let digit = ['0'-'9']
let whitespace = [' ' '\t' ]
let newline = ('\n' | '\r' '\n')

//--------------------------------------------------------------
// Part III. Token generators and rules.  
//
// These are the rules specifying the tokens matched by the lexer
//
// This lexer has only one generator ('token')
// 
// Generator definitions can take arguments, e.g.
//
//   rule token arg1 arg2 = parse ...


rule token = parse
| whitespace { token lexbuf }                          // keep lexing!
| newline    { record_newline lexbuf; token lexbuf }   // record line number and keep lexing!
| "let"    { LET }                                 // return a token!
| "letrec" { LETREC }
| "fun" { FUN }
| "in"    { IN }                                 // ...
| "begin"      { BEGIN }
| "end"      { END }
| "if"       { IF }
| "then"    { THEN }
| "else"    { ELSE }
| "("       { LPAREN }
| ")"       { RPAREN }
| "+"       { PLUS }
| "-"       { MINUS }
| "*"       { TIMES }
| "/"       { DIV }
| "="       { EQ }
| "->"      { ARROW }
| "."       { DOT }
| "<"       { LESS }
| ">"       { MORE }
| ";"       { SEMI }
| ['a'-'z']+    
            { ID(LexBuffer<_>.LexemeString lexbuf) }                     // return a token carrying data!
| ['-']?digit+  
            { INT (Int32.Parse(LexBuffer<_>.LexemeString lexbuf)) }      // return a token carrying data!
| eof   { EOF }                                           // return a token for the EOF

//
// Additional generator definitions would go here, e.g.
//
//   and comment arg1 arg2 = parse ...
//
//   and string arg1 arg2 = parse ...
